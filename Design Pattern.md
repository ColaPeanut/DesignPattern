# Design Pattern

# **设计模式、框架设计、架构**

个人理解：

设计模式主要强调**重用解决方案**

框架设计主要强调**重用代码**，框架设计可能包含许多的设计模式

架构是指一个具体的软件设计方案。

# **一、设计模式**

> 设计模式是语言无关的设计模式主要是研究类之间的关系设计模式的基石：多态

## **1.1 创建型模式**

> 这类模式提供创建对象的机制， 能够提升已有代码的灵活性和可复用性。

### **工厂模式**

工厂模式的多种实现：

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式

### **单例模式**

> 一个类只有一个实例，并提供一个访问该实例的全局节点。

### **为什么需要单例模式**

> 控制某些共享资源 （例如数据库或文件） 的访问权限，避免发生混乱。

### **单例模式的实现方式**

懒汉式：**懒的初始化**，第一次调用时才初始化（延迟初始化），避免内存浪费

饿汉式：**急着初始化**，类加载时就初始化，浪费内存

### **懒汉式**

> 多线程不安全，延迟初始化，多线程下可以产生多个实例，严格意义下不是单例模式

```
public class Singleton {
    private static Singleton instance;
    private Singleton (){}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### **懒汉式，线程安全**

> 多线程安全，延迟初始化，必须加锁 synchronized 才能保证单例，但加锁会影响效率

```
public class Singleton {
    private static Singleton instance;
    private Singleton (){}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### **饿汉式**

> 多线程安全，基于classloader 机制避免了多线程的同步问题，未加锁，效率高

```
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton (){}

    public static Singleton getInstance() {
        return instance;
    }
}
```

### **双检锁/双重校验锁 (DCL, double-checked locking)**

> 多线程安全，延迟初始化，采用双锁机制，多线程下能保持高性能

```
public class Singleton {
    private volatile static Singleton singleton;
    private Singleton (){}

    public static Singleton getSingleton() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

### **登记式/静态内部类**

> 多线程安全，延迟初始化，基于classloader 机制避免了多线程的同步问题

```
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton(){}

    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

### **枚举式**

> 多线程安全

```
public enum Singleton {
    INSTANCE;

    Singleton(){}
}
```

### **！！！**

- 单例模式实现的关键在于隐藏构造函数，避免外部创建实例

### **克隆模式/原型模式**

通过拷贝自身的属性来创建一个新对象

## **1.2 结构型模式**

> 这类模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。

### **适配器模式/变压器模式/包装模式**

将一个类的接口变成所期待的另一种接口，从而使得原本因接口不匹配的两个类能一起工作

适配器模式作用：

- 接口转换，将原有的接口（或方法）转换成另一中接口
- 用新的接口包装一个已有的接口
- 匹配一个老的组件到一个新的接口

### **组合模式/复合模式**

利用简单的成分构建复杂系统

### **装饰器模式**

动态的给类增加功能而不改变原代码

### **外观模式/门面模式**

为子系统中的一组接口提供一个一致的界面称为 外观模式， 外观模式定义了一个高层接口，这个接口使得这一子系统更容易使用。

用一个简单的接口来封装一个复杂的系统，使这个系统更容易使用。

### **享元模式**

节省内存，所有对象共享相同的属性

### **代理模式**

一个对象完成某项动作或任务，通过对另一个对象的引用来完成的

### **桥接模式**

## **1.3 行为模式**

> 这类模式负责对象间的高效沟通和职责委派。

### **观察者模式/监听模式**

观察对象的状态随着一个被观察对象的状态改变而改变

### **职责模式/责任链模式**

一个对象发出请求，有多个对象可以处理请求

### **状态模式**

一个对象在不同状态可以有不同的行为

三要素

- 上下文环境：定义当前状态，以及可以切换的状态
- 状态的抽象：状态的抽象类，定义统一的接口，规定每个子类（状态）必须实现的方法
- 拥有的状态：状态的实现类，不同状态有不同的行为

### **命令模式**

三要素：

- 命令：要完成的任务
- 接收者：任务实际执行者
- 调度者：命令者或接受任务者

### **中介模式/调停模式**

建立一个中间对象来完成多个对象之间的交互，改变交互模式，使之松耦合，简化结构。

多对多 -------> 一对多

### **备忘模式**

### **模板模式**

### **策略模式**

定义一系列可以互相替换的算法

- 三要素
    - 上下文环境：封装作用，避免外部直接调用各种策略
    - 策略的抽象：策略的抽象类，定义统一的接口，规定每个子类（策略）必须实现的方法
    - 拥有的策略：策略的实现类，可以有多种实现
- 对于一个问题，可以有多种应对策略，通过将各种策略进行封装，使得各种策略可以互相替换，同时可以方便的新增策略；
- 策略模式的各种策略实现有统一的接口
- 比如，回家，我们可以选择走路、骑自行车、打车、坐飞机。

### **访问模式**

### **迭代模式**

提供一种方法顺序地访问一组聚合对象（一个容器）中的各个元素，而又不需要暴露该对象的内部细节

## **1.4 其他**

### **构建模式/建造者模式**

### **解释模式**

### **过滤模式**

### **对象池机制**

### **回调机制**

### **MVC模式**

# **二、设计原则**

### **单一职责**

> 类的职责单一，引起类变化的原因单一

一个类只做一件事，类的变化只由于一个因素（功能变化）而变化

### **开放封闭**

> 对扩展开放，对修改关闭

### **里氏替换**

> 派生类可以完全取代基类

通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能

### **接口隔离**

> 客户端不依赖于它们不使用的接口

### **依赖倒置/控制反转**

> 高层级的模块不应该依赖于低层级的模块，它们都应该依赖抽象;细节依赖于抽象，而不是抽象依赖于细节

任何两个模块都不应以紧密方式相互依赖，可以在它们直接之间提供一个抽象层来耦合

# **三、对比**

### **策略模式和状态模式**

两者有非常相似的结构，但目标不同：

- 策略模式强调一个问题可以有多种解决方案
- 状态模式强调一个对象处于不同状态有不同的行为
- 策略之间是独立的，状态之间有一定的关联（一个状态可以转换到哪些状态）

### **门面模式和适配器模式**

- 门面模式试图从复杂接口中抽象出一个简化版本
- 适配器模式试图将不同接口链接到一起

### **构建模式和组合模式的区别**